<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红黑树模板 (Red-Black Tree)</title>
      <link href="/2023/10/30/red-black-tree-template/"/>
      <url>/2023/10/30/red-black-tree-template/</url>
      
        <content type="html"><![CDATA[<p>理论上来说根据 GPL v2 可以自由分发，所以在这里贴上作者应该就不是什么大问题了（确信）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; SPDX-License-Identifier: GPL-2.0-or-later&#x2F;*  Red Black Trees  (C) 1999  Andrea Arcangeli &lt;andrea@suse.de&gt;  (C) 2002  David Woodhouse &lt;dwmw2@infradead.org&gt;  (C) 2012  Michel Lespinasse &lt;walken@google.com&gt;  linux&#x2F;lib&#x2F;rbtree.c*&#x2F;&#x2F;&#x2F; #include &lt;linux&#x2F;rbtree_augmented.h&gt;&#x2F;&#x2F; #include &lt;linux&#x2F;export.h&gt;&#x2F;* * red-black trees properties:  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rbtree * *  1) A node is either red or black *  2) The root is black *  3) All leaves (NULL) are black *  4) Both children of every red node are black *  5) Every simple path from root to leaves contains the same number *     of black nodes. * *  4 and 5 give the O(log n) guarantee, since 4 implies you cannot have two *  consecutive red nodes in a path and every red node is therefore followed by *  a black. So if B is the number of black nodes on every simple path (as per *  5), then the longest possible path due to 4 is 2B. * *  We shall indicate color with case, where black nodes are uppercase and red *  nodes will be lowercase. Unknown color nodes shall be drawn as red within *  parentheses and have some accompanying text comment. *&#x2F;&#x2F;* * Notes on lockless lookups: * * All stores to the tree structure (rb_left and rb_right) must be done using * WRITE_ONCE(). And we must not inadvertently cause (temporary) loops in the * tree structure as seen in program order. * * These two requirements will allow lockless iteration of the tree -- not * correct iteration mind you, tree rotations are not atomic so a lookup might * miss entire subtrees. * * But they do guarantee that any such traversal will only see valid elements * and that it will indeed complete -- does not get stuck in a loop. * * It also guarantees that if the lookup returns an element it is the &#39;correct&#39; * one. But not returning an element does _NOT_ mean it&#39;s not present. * * NOTE: * * Stores to __rb_parent_color are not important for simple lookups so those * are left undone as of now. Nor did I check for loops involving parent * pointers. *&#x2F;static inline void rb_set_black(struct rb_node *rb)&#123;rb-&gt;__rb_parent_color +&#x3D; RB_BLACK;&#125;static inline struct rb_node *rb_red_parent(struct rb_node *red)&#123;return (struct rb_node *)red-&gt;__rb_parent_color;&#125;&#x2F;* * Helper function for rotations: * - old&#39;s parent and color get assigned to new * - old gets assigned new as a parent and &#39;color&#39; as a color. *&#x2F;static inline void__rb_rotate_set_parents(struct rb_node *old, struct rb_node *new,struct rb_root *root, int color)&#123;struct rb_node *parent &#x3D; rb_parent(old);new-&gt;__rb_parent_color &#x3D; old-&gt;__rb_parent_color;rb_set_parent_color(old, new, color);__rb_change_child(old, new, parent, root);&#125;static __always_inline void__rb_insert(struct rb_node *node, struct rb_root *root,    void (*augment_rotate)(struct rb_node *old, struct rb_node *new))&#123;struct rb_node *parent &#x3D; rb_red_parent(node), *gparent, *tmp;while (true) &#123;&#x2F;* * Loop invariant: node is red. *&#x2F;if (unlikely(!parent)) &#123;&#x2F;* * The inserted node is root. Either this is the * first node, or we recursed at Case 1 below and * are no longer violating 4). *&#x2F;rb_set_parent_color(node, NULL, RB_BLACK);break;&#125;&#x2F;* * If there is a black parent, we are done. * Otherwise, take some corrective action as, * per 4), we don&#39;t want a red root or two * consecutive red nodes. *&#x2F;if(rb_is_black(parent))break;gparent &#x3D; rb_red_parent(parent);tmp &#x3D; gparent-&gt;rb_right;if (parent !&#x3D; tmp) &#123;&#x2F;* parent &#x3D;&#x3D; gparent-&gt;rb_left *&#x2F;if (tmp &amp;&amp; rb_is_red(tmp)) &#123;&#x2F;* * Case 1 - node&#39;s uncle is red (color flips). * *       G            g *      &#x2F; \          &#x2F; \ *     p   u  --&gt;   P   U *    &#x2F;            &#x2F; *   n            n * * However, since g&#39;s parent might be red, and * 4) does not allow this, we need to recurse * at g. *&#x2F;rb_set_parent_color(tmp, gparent, RB_BLACK);rb_set_parent_color(parent, gparent, RB_BLACK);node &#x3D; gparent;parent &#x3D; rb_parent(node);rb_set_parent_color(node, parent, RB_RED);continue;&#125;tmp &#x3D; parent-&gt;rb_right;if (node &#x3D;&#x3D; tmp) &#123;&#x2F;* * Case 2 - node&#39;s uncle is black and node is * the parent&#39;s right child (left rotate at parent). * *      G             G *     &#x2F; \           &#x2F; \ *    p   U  --&gt;    n   U *     \           &#x2F; *      n         p * * This still leaves us in violation of 4), the * continuation into Case 3 will fix that. *&#x2F;tmp &#x3D; node-&gt;rb_left;WRITE_ONCE(parent-&gt;rb_right, tmp);WRITE_ONCE(node-&gt;rb_left, parent);if (tmp)rb_set_parent_color(tmp, parent,    RB_BLACK);rb_set_parent_color(parent, node, RB_RED);augment_rotate(parent, node);parent &#x3D; node;tmp &#x3D; node-&gt;rb_right;&#125;&#x2F;* * Case 3 - node&#39;s uncle is black and node is * the parent&#39;s left child (right rotate at gparent). * *        G           P *       &#x2F; \         &#x2F; \ *      p   U  --&gt;  n   g *     &#x2F;                 \ *    n                   U *&#x2F;WRITE_ONCE(gparent-&gt;rb_left, tmp); &#x2F;* &#x3D;&#x3D; parent-&gt;rb_right *&#x2F;WRITE_ONCE(parent-&gt;rb_right, gparent);if (tmp)rb_set_parent_color(tmp, gparent, RB_BLACK);__rb_rotate_set_parents(gparent, parent, root, RB_RED);augment_rotate(gparent, parent);break;&#125; else &#123;tmp &#x3D; gparent-&gt;rb_left;if (tmp &amp;&amp; rb_is_red(tmp)) &#123;&#x2F;* Case 1 - color flips *&#x2F;rb_set_parent_color(tmp, gparent, RB_BLACK);rb_set_parent_color(parent, gparent, RB_BLACK);node &#x3D; gparent;parent &#x3D; rb_parent(node);rb_set_parent_color(node, parent, RB_RED);continue;&#125;tmp &#x3D; parent-&gt;rb_left;if (node &#x3D;&#x3D; tmp) &#123;&#x2F;* Case 2 - right rotate at parent *&#x2F;tmp &#x3D; node-&gt;rb_right;WRITE_ONCE(parent-&gt;rb_left, tmp);WRITE_ONCE(node-&gt;rb_right, parent);if (tmp)rb_set_parent_color(tmp, parent,    RB_BLACK);rb_set_parent_color(parent, node, RB_RED);augment_rotate(parent, node);parent &#x3D; node;tmp &#x3D; node-&gt;rb_left;&#125;&#x2F;* Case 3 - left rotate at gparent *&#x2F;WRITE_ONCE(gparent-&gt;rb_right, tmp); &#x2F;* &#x3D;&#x3D; parent-&gt;rb_left *&#x2F;WRITE_ONCE(parent-&gt;rb_left, gparent);if (tmp)rb_set_parent_color(tmp, gparent, RB_BLACK);__rb_rotate_set_parents(gparent, parent, root, RB_RED);augment_rotate(gparent, parent);break;&#125;&#125;&#125;&#x2F;* * Inline version for rb_erase() use - we want to be able to inline * and eliminate the dummy_rotate callback there *&#x2F;static __always_inline void____rb_erase_color(struct rb_node *parent, struct rb_root *root,void (*augment_rotate)(struct rb_node *old, struct rb_node *new))&#123;struct rb_node *node &#x3D; NULL, *sibling, *tmp1, *tmp2;while (true) &#123;&#x2F;* * Loop invariants: * - node is black (or NULL on first iteration) * - node is not the root (parent is not NULL) * - All leaf paths going through parent and node have a *   black node count that is 1 lower than other leaf paths. *&#x2F;sibling &#x3D; parent-&gt;rb_right;if (node !&#x3D; sibling) &#123;&#x2F;* node &#x3D;&#x3D; parent-&gt;rb_left *&#x2F;if (rb_is_red(sibling)) &#123;&#x2F;* * Case 1 - left rotate at parent * *     P               S *    &#x2F; \             &#x2F; \ *   N   s    --&gt;    p   Sr *      &#x2F; \         &#x2F; \ *     Sl  Sr      N   Sl *&#x2F;tmp1 &#x3D; sibling-&gt;rb_left;WRITE_ONCE(parent-&gt;rb_right, tmp1);WRITE_ONCE(sibling-&gt;rb_left, parent);rb_set_parent_color(tmp1, parent, RB_BLACK);__rb_rotate_set_parents(parent, sibling, root,RB_RED);augment_rotate(parent, sibling);sibling &#x3D; tmp1;&#125;tmp1 &#x3D; sibling-&gt;rb_right;if (!tmp1 || rb_is_black(tmp1)) &#123;tmp2 &#x3D; sibling-&gt;rb_left;if (!tmp2 || rb_is_black(tmp2)) &#123;&#x2F;* * Case 2 - sibling color flip * (p could be either color here) * *    (p)           (p) *    &#x2F; \           &#x2F; \ *   N   S    --&gt;  N   s *      &#x2F; \           &#x2F; \ *     Sl  Sr        Sl  Sr * * This leaves us violating 5) which * can be fixed by flipping p to black * if it was red, or by recursing at p. * p is red when coming from Case 1. *&#x2F;rb_set_parent_color(sibling, parent,    RB_RED);if (rb_is_red(parent))rb_set_black(parent);else &#123;node &#x3D; parent;parent &#x3D; rb_parent(node);if (parent)continue;&#125;break;&#125;&#x2F;* * Case 3 - right rotate at sibling * (p could be either color here) * *   (p)           (p) *   &#x2F; \           &#x2F; \ *  N   S    --&gt;  N   sl *     &#x2F; \             \ *    sl  Sr            S *                       \ *                        Sr * * Note: p might be red, and then both * p and sl are red after rotation(which * breaks property 4). This is fixed in * Case 4 (in __rb_rotate_set_parents() *         which set sl the color of p *         and set p RB_BLACK) * *   (p)            (sl) *   &#x2F; \            &#x2F;  \ *  N   sl   --&gt;   P    S *       \        &#x2F;      \ *        S      N        Sr *         \ *          Sr *&#x2F;tmp1 &#x3D; tmp2-&gt;rb_right;WRITE_ONCE(sibling-&gt;rb_left, tmp1);WRITE_ONCE(tmp2-&gt;rb_right, sibling);WRITE_ONCE(parent-&gt;rb_right, tmp2);if (tmp1)rb_set_parent_color(tmp1, sibling,    RB_BLACK);augment_rotate(sibling, tmp2);tmp1 &#x3D; sibling;sibling &#x3D; tmp2;&#125;&#x2F;* * Case 4 - left rotate at parent + color flips * (p and sl could be either color here. *  After rotation, p becomes black, s acquires *  p&#39;s color, and sl keeps its color) * *      (p)             (s) *      &#x2F; \             &#x2F; \ *     N   S     --&gt;   P   Sr *        &#x2F; \         &#x2F; \ *      (sl) sr      N  (sl) *&#x2F;tmp2 &#x3D; sibling-&gt;rb_left;WRITE_ONCE(parent-&gt;rb_right, tmp2);WRITE_ONCE(sibling-&gt;rb_left, parent);rb_set_parent_color(tmp1, sibling, RB_BLACK);if (tmp2)rb_set_parent(tmp2, parent);__rb_rotate_set_parents(parent, sibling, root,RB_BLACK);augment_rotate(parent, sibling);break;&#125; else &#123;sibling &#x3D; parent-&gt;rb_left;if (rb_is_red(sibling)) &#123;&#x2F;* Case 1 - right rotate at parent *&#x2F;tmp1 &#x3D; sibling-&gt;rb_right;WRITE_ONCE(parent-&gt;rb_left, tmp1);WRITE_ONCE(sibling-&gt;rb_right, parent);rb_set_parent_color(tmp1, parent, RB_BLACK);__rb_rotate_set_parents(parent, sibling, root,RB_RED);augment_rotate(parent, sibling);sibling &#x3D; tmp1;&#125;tmp1 &#x3D; sibling-&gt;rb_left;if (!tmp1 || rb_is_black(tmp1)) &#123;tmp2 &#x3D; sibling-&gt;rb_right;if (!tmp2 || rb_is_black(tmp2)) &#123;&#x2F;* Case 2 - sibling color flip *&#x2F;rb_set_parent_color(sibling, parent,    RB_RED);if (rb_is_red(parent))rb_set_black(parent);else &#123;node &#x3D; parent;parent &#x3D; rb_parent(node);if (parent)continue;&#125;break;&#125;&#x2F;* Case 3 - left rotate at sibling *&#x2F;tmp1 &#x3D; tmp2-&gt;rb_left;WRITE_ONCE(sibling-&gt;rb_right, tmp1);WRITE_ONCE(tmp2-&gt;rb_left, sibling);WRITE_ONCE(parent-&gt;rb_left, tmp2);if (tmp1)rb_set_parent_color(tmp1, sibling,    RB_BLACK);augment_rotate(sibling, tmp2);tmp1 &#x3D; sibling;sibling &#x3D; tmp2;&#125;&#x2F;* Case 4 - right rotate at parent + color flips *&#x2F;tmp2 &#x3D; sibling-&gt;rb_right;WRITE_ONCE(parent-&gt;rb_left, tmp2);WRITE_ONCE(sibling-&gt;rb_right, parent);rb_set_parent_color(tmp1, sibling, RB_BLACK);if (tmp2)rb_set_parent(tmp2, parent);__rb_rotate_set_parents(parent, sibling, root,RB_BLACK);augment_rotate(parent, sibling);break;&#125;&#125;&#125;&#x2F;* Non-inline version for rb_erase_augmented() use *&#x2F;void __rb_erase_color(struct rb_node *parent, struct rb_root *root,void (*augment_rotate)(struct rb_node *old, struct rb_node *new))&#123;____rb_erase_color(parent, root, augment_rotate);&#125;EXPORT_SYMBOL(__rb_erase_color);&#x2F;* * Non-augmented rbtree manipulation functions. * * We use dummy augmented callbacks here, and have the compiler optimize them * out of the rb_insert_color() and rb_erase() function definitions. *&#x2F;static inline void dummy_propagate(struct rb_node *node, struct rb_node *stop) &#123;&#125;static inline void dummy_copy(struct rb_node *old, struct rb_node *new) &#123;&#125;static inline void dummy_rotate(struct rb_node *old, struct rb_node *new) &#123;&#125;static const struct rb_augment_callbacks dummy_callbacks &#x3D; &#123;.propagate &#x3D; dummy_propagate,.copy &#x3D; dummy_copy,.rotate &#x3D; dummy_rotate&#125;;void rb_insert_color(struct rb_node *node, struct rb_root *root)&#123;__rb_insert(node, root, dummy_rotate);&#125;EXPORT_SYMBOL(rb_insert_color);void rb_erase(struct rb_node *node, struct rb_root *root)&#123;struct rb_node *rebalance;rebalance &#x3D; __rb_erase_augmented(node, root, &amp;dummy_callbacks);if (rebalance)____rb_erase_color(rebalance, root, dummy_rotate);&#125;EXPORT_SYMBOL(rb_erase);&#x2F;* * Augmented rbtree manipulation functions. * * This instantiates the same __always_inline functions as in the non-augmented * case, but this time with user-defined callbacks. *&#x2F;void __rb_insert_augmented(struct rb_node *node, struct rb_root *root,void (*augment_rotate)(struct rb_node *old, struct rb_node *new))&#123;__rb_insert(node, root, augment_rotate);&#125;EXPORT_SYMBOL(__rb_insert_augmented);&#x2F;* * This function returns the first node (in sort order) of the tree. *&#x2F;struct rb_node *rb_first(const struct rb_root *root)&#123;struct rb_node*n;n &#x3D; root-&gt;rb_node;if (!n)return NULL;while (n-&gt;rb_left)n &#x3D; n-&gt;rb_left;return n;&#125;EXPORT_SYMBOL(rb_first);struct rb_node *rb_last(const struct rb_root *root)&#123;struct rb_node*n;n &#x3D; root-&gt;rb_node;if (!n)return NULL;while (n-&gt;rb_right)n &#x3D; n-&gt;rb_right;return n;&#125;EXPORT_SYMBOL(rb_last);struct rb_node *rb_next(const struct rb_node *node)&#123;struct rb_node *parent;if (RB_EMPTY_NODE(node))return NULL;&#x2F;* * If we have a right-hand child, go down and then left as far * as we can. *&#x2F;if (node-&gt;rb_right) &#123;node &#x3D; node-&gt;rb_right;while (node-&gt;rb_left)node &#x3D; node-&gt;rb_left;return (struct rb_node *)node;&#125;&#x2F;* * No right-hand children. Everything down and left is smaller than us, * so any &#39;next&#39; node must be in the general direction of our parent. * Go up the tree; any time the ancestor is a right-hand child of its * parent, keep going up. First time it&#39;s a left-hand child of its * parent, said parent is our &#39;next&#39; node. *&#x2F;while ((parent &#x3D; rb_parent(node)) &amp;&amp; node &#x3D;&#x3D; parent-&gt;rb_right)node &#x3D; parent;return parent;&#125;EXPORT_SYMBOL(rb_next);struct rb_node *rb_prev(const struct rb_node *node)&#123;struct rb_node *parent;if (RB_EMPTY_NODE(node))return NULL;&#x2F;* * If we have a left-hand child, go down and then right as far * as we can. *&#x2F;if (node-&gt;rb_left) &#123;node &#x3D; node-&gt;rb_left;while (node-&gt;rb_right)node &#x3D; node-&gt;rb_right;return (struct rb_node *)node;&#125;&#x2F;* * No left-hand children. Go up till we find an ancestor which * is a right-hand child of its parent. *&#x2F;while ((parent &#x3D; rb_parent(node)) &amp;&amp; node &#x3D;&#x3D; parent-&gt;rb_left)node &#x3D; parent;return parent;&#125;EXPORT_SYMBOL(rb_prev);void rb_replace_node(struct rb_node *victim, struct rb_node *new,     struct rb_root *root)&#123;struct rb_node *parent &#x3D; rb_parent(victim);&#x2F;* Copy the pointers&#x2F;colour from the victim to the replacement *&#x2F;*new &#x3D; *victim;&#x2F;* Set the surrounding nodes to point to the replacement *&#x2F;if (victim-&gt;rb_left)rb_set_parent(victim-&gt;rb_left, new);if (victim-&gt;rb_right)rb_set_parent(victim-&gt;rb_right, new);__rb_change_child(victim, new, parent, root);&#125;EXPORT_SYMBOL(rb_replace_node);void rb_replace_node_rcu(struct rb_node *victim, struct rb_node *new, struct rb_root *root)&#123;struct rb_node *parent &#x3D; rb_parent(victim);&#x2F;* Copy the pointers&#x2F;colour from the victim to the replacement *&#x2F;*new &#x3D; *victim;&#x2F;* Set the surrounding nodes to point to the replacement *&#x2F;if (victim-&gt;rb_left)rb_set_parent(victim-&gt;rb_left, new);if (victim-&gt;rb_right)rb_set_parent(victim-&gt;rb_right, new);&#x2F;* Set the parent&#39;s pointer to the new node last after an RCU barrier * so that the pointers onwards are seen to be set correctly when doing * an RCU walk over the tree. *&#x2F;__rb_change_child_rcu(victim, new, parent, root);&#125;EXPORT_SYMBOL(rb_replace_node_rcu);static struct rb_node *rb_left_deepest_node(const struct rb_node *node)&#123;for (;;) &#123;if (node-&gt;rb_left)node &#x3D; node-&gt;rb_left;else if (node-&gt;rb_right)node &#x3D; node-&gt;rb_right;elsereturn (struct rb_node *)node;&#125;&#125;struct rb_node *rb_next_postorder(const struct rb_node *node)&#123;const struct rb_node *parent;if (!node)return NULL;parent &#x3D; rb_parent(node);&#x2F;* If we&#39;re sitting on node, we&#39;ve already seen our children *&#x2F;if (parent &amp;&amp; node &#x3D;&#x3D; parent-&gt;rb_left &amp;&amp; parent-&gt;rb_right) &#123;&#x2F;* If we are the parent&#39;s left node, go to the parent&#39;s right * node then all the way down to the left *&#x2F;return rb_left_deepest_node(parent-&gt;rb_right);&#125; else&#x2F;* Otherwise we are the parent&#39;s right node, and the parent * should be next *&#x2F;return (struct rb_node *)parent;&#125;EXPORT_SYMBOL(rb_next_postorder);struct rb_node *rb_first_postorder(const struct rb_root *root)&#123;if (!root-&gt;rb_node)return NULL;return rb_left_deepest_node(root-&gt;rb_node);&#125;EXPORT_SYMBOL(rb_first_postorder);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cambridge dictionary 单词查询程序</title>
      <link href="/2023/10/29/cambridge-dictionary-query-program/"/>
      <url>/2023/10/29/cambridge-dictionary-query-program/</url>
      
        <content type="html"><![CDATA[<p>程序会自动从 <code>word.in</code> 中获取信息并输出结果，输入格式如下：</p><p>第一行 $ n $ 为书本数量，以下有 $ n $ 组数据，每组的第一行为书本名称，第二行为页数 $ m $ ，下有 $ m $ 组数据，每组的第 $ 1~3 $ 行 分别为页码、标题和单词数量 $ k $ ，下有 $ k $ 个单词。</p><p>程序会自动输出 test.tex 。</p><p>请确保你安装了 requests、bs4、lxml模块。</p><p>请将以下两个文件放到同一个目录下运行。</p><p>main.py:</p><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;usr&#x2F;bin&#x2F;python3# encoding&#x3D;utf-8import requests, os, sysfrom bs4 import BeautifulSoupfrom write import *# from tqdm import tqdmfrom requests.adapters import HTTPAdapterfrom requests.packages.urllib3.util.retry import Retryos.chdir(os.getcwd() + &quot;&#x2F;Something else&#x2F;20231019&#x2F;&quot;)head &#x3D; &quot;&quot;&quot;\\documentclass[a4paper,margin&#x3D;1.0cm,10.5pt]&#123;book&#125;\\usepackage[UTF8]&#123;ctex&#125;\\usepackage&#123;tipa&#125;\\usepackage&#123;color&#125;\\usepackage&#123;geometry&#125;\\usepackage&#123;fontspec&#125;\\usepackage&#123;xcolor&#125;\\usepackage&#123;titlesec&#125;\\defaultfontfeatures&#123;Ligatures&#x3D;TeX&#125;\\setmainfont&#123;Times New Roman&#125;\\renewcommand&#123;\\large&#125;&#123;\\fontsize&#123;14pt&#125;&#123;\\baselineskip&#125;\\selectfont&#125;\\definecolor&#123;Purple&#125;&#123;rgb&#125;&#123;.256,.0,.511&#125;\\newfontfamily\\sectionfont[Color&#x3D;Purple]&#123;Times New Roman&#125;\\titleformat*&#123;\\section&#125;&#123;\\large\\bfseries\\sffamily\\color&#123;Purple&#125;&#125;\\begin&#123;document&#125;\\title&#123;Vocabulary&#125;\\maketitle\\pagenumbering&#123;roman&#125;\\tableofcontents\\newpage\\pagenumbering&#123;arabic&#125;&quot;&quot;&quot;tail &#x3D; &quot;&quot;&quot;\\end&#123;document&#125;&quot;&quot;&quot;header &#x3D; &#123;&quot;Cookie&quot;: &#39;XSRF-TOKEN&#x3D;091b0a7e-7b7c-440f-82ba-7853a686d0e8; preferredDictionaries&#x3D;&quot;english-chinese-simplified,english-chinese-traditional,english,british-grammar&quot;; _ga&#x3D;GA1.3.1985437458.1697684466; _gid&#x3D;GA1.3.1397756659.1697684466; amp-access&#x3D;amp-DgWec-PNndO292HPfqJugg; _hjFirstSeen&#x3D;1; _hjSession_2790984&#x3D;eyJpZCI6Ijc4ZmUwMGE3LTM0MjQtNGNhNi1hMjYwLTE3Yjc3YmQxMTE0MSIsImNyZWF0ZWQiOjE2OTc2ODQ0Njc0NTcsImluU2FtcGxlIjpmYWxzZSwic2Vzc2lvbml6ZXJCZXRhRW5hYmxlZCI6dHJ1ZX0&#x3D;; _sp_ses.7ecc&#x3D;*; OptanonConsent&#x3D;isGpcEnabled&#x3D;0&amp;datestamp&#x3D;Thu+Oct+19+2023+11%3A01%3A20+GMT%2B0800+(China+Standard+Time)&amp;version&#x3D;202308.1.0&amp;browserGpcFlag&#x3D;0&amp;isIABGlobal&#x3D;false&amp;hosts&#x3D;&amp;landingPath&#x3D;NotLandingPage&amp;groups&#x3D;C0001%3A1%2CC0002%3A1%2CC0003%3A1%2CC0004%3A0&amp;AwaitingReconsent&#x3D;false; _sp_id.7ecc&#x3D;3979def0-c2d7-4674-82ae-82dabd30e180.1697684468.1.1697684480..0b270403-3325-4540-80fe-b9939b45295d....0; _hjSessionUser_2790984&#x3D;eyJpZCI6IjllMjU2Zjk3LTU5ZjAtNWNhYi1hYzI4LWUyZDlhYmIzOGY4ZiIsImNyZWF0ZWQiOjE2OTc2ODQ0Njc0NTcsImV4aXN0aW5nIjp0cnVlfQ&#x3D;&#x3D;; _gat&#x3D;1; iawsc1m&#x3D;1; _sharedID&#x3D;54582c27-481b-45f6-af8b-567598974fc2; _sharedID_cst&#x3D;zix7LPQsHA%3D%3D; _pbjs_userid_consent_data&#x3D;3524755945110770; _sharedid&#x3D;0362b518-b56a-4a08-9f01-687b29d9e710; _lr_retry_request&#x3D;true; _lr_env_src_ats&#x3D;false; pbjs-unifiedid&#x3D;%7B%22TDID%22%3A%22b82f813d-b87d-406b-920c-4d28ffdd6e63%22%2C%22TDID_LOOKUP%22%3A%22TRUE%22%2C%22TDID_CREATED_AT%22%3A%222023-09-19T03%3A10%3A42%22%7D; pbjs-unifiedid_cst&#x3D;zix7LPQsHA%3D%3D; loginPopup&#x3D;5; _ga_L9GCR21SZ7&#x3D;GS1.3.1697684466.1.1.1697685069.27.0.0; iawpvccs&#x3D;4; iawpvc&#x3D;4; iawpvtc1m&#x3D;4; cto_bundle&#x3D;-fkA8F9VeGgzOEh2TlVBQyUyQnowREg4QkhxZlY5USUyQnRrdSUyQmQ3ZHFlSTRJJTJCTmppNmt1WCUyRlFxQWhKSlNKN1d6T0NwU3Z1RUx6WmUxSmxqOWd4RHROekZuclFJZCUyRjZQYnNyTjVoSmRpUzBpSyUyQmdGWnI3bHFVZFZ4Q3YzU1hxd0JQZmMlMkJFV0NUZjAlMkZuQm96NU9BNU14M2RVSkxaS0ElM0QlM0Q; cto_bidid&#x3D;PEgR8V9vZWpoUjBET21nT0lHSUhkZUMySG1WZUhYMDJFbGxmUUR5cFJxUTZhejNRY3lmNWFDZlJrRjlJTDRoMnNxQTFlaTJKd3U3Z3BWdmx0S3FBNXZVZU8xMEZmbUQwVUZKRXpRdFNqSFZYZ3RQdyUzRA&#39;,&quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;118.0.0.0 Safari&#x2F;537.36 Edg&#x2F;118.0.2088.46&quot;,&quot;sec-ch-ua-mobile&quot;: &quot;0&quot;,&#125;file &#x3D; open(&quot;test.tex&quot;, &quot;w+&quot;)stdin &#x3D; open(&quot;word.in&quot;, &quot;r&quot;)file.write(head)# book &#x3D; input(&quot;请输入书本:&quot;)cntbook &#x3D; int(stdin.readline())lock&#x3D;threading.Lock()def solve(word):# templine.set_description(&quot;Processing &quot;+nowpage)word &#x3D; word.replace(&quot; &quot;,&quot;-&quot;)word &#x3D; word.replace(&quot;&#x2F;&quot;,&quot;-&quot;)session &#x3D; requests.Session()retry &#x3D; Retry(total&#x3D;114514, backoff_factor&#x3D;5)adapter &#x3D; HTTPAdapter(max_retries&#x3D;retry)session.mount(&#39;http:&#x2F;&#x2F;&#39;, adapter)session.mount(&#39;https:&#x2F;&#x2F;&#39;, adapter)response &#x3D; session.get(&quot;https:&#x2F;&#x2F;dictionary.cambridge.org&#x2F;dictionary&#x2F;english-chinese-simplified&#x2F;&quot;+ word,headers&#x3D;header,)contentori &#x3D; BeautifulSoup(response.text, &quot;lxml&quot;)try:word &#x3D; contentori.find_all(&quot;span&quot;,class_&#x3D;&quot;hw dhw&quot;)[0].textexcept:print(&quot;Error occured on word &quot;+word+&quot;, please check the code or spelling.&quot;)# tempfile &#x3D; open(&quot;test.out&quot;,&quot;r&quot;)# temptext &#x3D; tempfile.read()# tempfile.close()# content &#x3D; BeautifulSoup(temptext ,&quot;lxml&quot;)# print(content)try:lock.acquire()for content1 in contentori.find_all(&quot;div&quot;, class_&#x3D;&quot;pr entry-body__el&quot;):temp &#x3D; content1.find_all(&quot;div&quot;, class_&#x3D;&quot;pr dsense&quot;)pronoun&#x3D;&quot;&quot;try:pronoun &#x3D; content1.find_all(&quot;span&quot;, class_&#x3D;&quot;pron dpron&quot;)[0].textexcept:passtry:part_of_speech &#x3D; content1.find_all(&quot;span&quot;, class_&#x3D;&quot;pos dsense_pos&quot;)[0].textexcept:part_of_speech &#x3D; content1.find_all(&quot;span&quot;,class_&#x3D;&quot;pos dpos&quot;)[0].textattri&#x3D;&quot;&quot;try:attri &#x3D; content1.find_all(&quot;span&quot;, class_&#x3D;&quot;dgram&quot;)[0].textexcept:passtemp2 &#x3D; content1.find_all(&quot;div&quot;,class_&#x3D;&quot;def-block ddef_block&quot;)for content in temp2:chinese &#x3D; content.find_all(&quot;span&quot;, class_&#x3D;&quot;trans dtrans dtrans-se break-cj&quot;)[0].texttry:attri &#x3D; content.find_all(&quot;span&quot;, class_&#x3D;&quot;dgram&quot;)[0].textexcept:passdescribe &#x3D; content.find_all(&quot;span&quot;, class_&#x3D;&quot;guideword dsense_gw&quot;)example_ENG &#x3D; content.find_all(&quot;span&quot;, class_&#x3D;&quot;eg deg&quot;)example_CHI &#x3D; content.find_all(&quot;span&quot;, class_&#x3D;&quot;trans dtrans dtrans-se hdb break-cj&quot;)sentence &#x3D; content.find_all(&quot;li&quot;, class_&#x3D;&quot;eg dexamp hax&quot;)write(file,word,pronoun,chinese,part_of_speech,attri,example_CHI,example_ENG,sentence,)lock.release()# else:# # content &#x3D; temp[0]# chinese &#x3D; contentori.find_all(# &quot;span&quot;, class_&#x3D;&quot;trans dtrans dtrans-se break-cj&quot;# )[0].text# part_of_speech &#x3D; &quot;&quot;# try:# part_of_speech &#x3D; contentori.find_all(&quot;span&quot;, class_&#x3D;&quot;pos dpos&quot;)[0].text# except IndexError:# part_of_speech &#x3D; contentori.find_all(&quot;span&quot;, class_&#x3D;&quot;pos dsense_pos&quot;)[# 0# ].text# attri &#x3D; &quot;&quot;# try:# attri &#x3D; contentori.find_all(&quot;span&quot;, class_&#x3D;&quot;dgram&quot;)[0].text# except:# pass# describe &#x3D; contentori.find_all(&quot;span&quot;, class_&#x3D;&quot;guideword dsense_gw&quot;)# example_ENG &#x3D; contentori.find_all(&quot;span&quot;, class_&#x3D;&quot;eg deg&quot;)# example_CHI &#x3D; contentori.find_all(# &quot;span&quot;, class_&#x3D;&quot;trans dtrans dtrans-se hdb break-cj&quot;# )# sentence &#x3D; contentori.find_all(&quot;li&quot;, class_&#x3D;&quot;eg dexamp hax&quot;)# write(# file,# word,# pronoun,# chinese,# part_of_speech,# attri,# example_CHI,# example_ENG,# sentence,# )except:print(&quot;Error occured on word &quot;+word+&quot;, please check the code or spelling.&quot;)lock.release()# file.write(&quot;\n\n\n&quot;)for nowbook in range(cntbook):book &#x3D; stdin.readline().replace(&quot;\n&quot;,&quot;&quot;)page &#x3D; int(stdin.readline())file.write(&quot;\\chapter&#123;&quot; + book + &quot;&#125;\n&quot;)for i in range(page):# temp &#x3D; stdin.readline().split()nowpage &#x3D; stdin.readline().replace(&quot;\n&quot;, &quot;&quot;)# print(&quot;processing &quot;+nowpage)file.write(&quot;\\textcolor[RGB]&#123;128,0,255&#125;&#123;\\section&#123;&quot;+ book+ &quot; &quot;+ nowpage+ &quot; &quot;+ stdin.readline().replace(&quot;\n&quot;, &quot;&quot;)+ &quot;&#125;&#125;\n&quot;)# file.write(&quot;\\begin&#123;enumerate&#125;\n&quot;)# cnt &#x3D; int(stdin.readline())cnt&#x3D;int(stdin.readline())words&#x3D;[]for i in range(cnt):words.append(stdin.readline().replace(&quot;\n&quot;,&quot;&quot;))# words &#x3D; stdin.readline()threadings &#x3D; []for word in words:threadings.append(threading.Thread(target&#x3D;solve,args&#x3D;[word,],))for t in threadings:t.start()# for t in threadings:t.join()file.write(tail)file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>write.py:</p><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;usr&#x2F;bin&#x2F;python3# encoding&#x3D;utf-8import threadingshape &#x3D; &quot;&quot;lock&#x3D;threading.Lock()def write(file, # 要写入的文件word&#x3D;&quot;&quot;, # 原文pronunciation&#x3D;&quot;&quot;, # 音标chinese&#x3D;&quot;&quot;, # 中文part_of_speech&#x3D;&quot;&quot;, # 词性attri&#x3D;&quot;&quot;, # 其他属性，如是否可数example_CHN&#x3D;[], # 例子中文example_ENG&#x3D;[], # 例子英文sentence&#x3D;[], # 只有英文的例句):try:# pronunciation&#x3D;pronunciation.replace(&quot;ː&quot;,&quot; \\textlengthmark &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ˈ&quot;,&quot; \\textprimstress &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ɪ&quot;,&quot; \\i &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ɔ&quot;,&quot; \\textopeno &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ɒ&quot;,&quot; \\textturnscripta &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ʃ&quot;,&quot; \\textesh &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ˌ&quot;, &quot;\\textsecstress &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ʒ&quot;,&quot; \\textyogh &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ʌ&quot;,&quot; \\textturnv &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ɡ&quot;,&quot; \\textscriptg &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ɑ&quot;,&quot; \\textscripta &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ʊ&quot;,&quot; \\textupsilon &quot;)# pronunciation&#x3D;pronunciation.replace(&quot;ɜ&quot;,&quot; \\textrevepsilon &quot;)lock.acquire()file.write(&quot;\\begin&#123;itemize&#125;\n&quot;)attri&#x3D;attri.replace(&quot;C&quot;,&quot; $ C $ &quot;)attri&#x3D;attri.replace(&quot;U&quot;,&quot; $ U $ &quot;)attri&#x3D;attri.replace(&quot;I&quot;,&quot; $ I $ &quot;)attri&#x3D;attri.replace(&quot;T&quot;,&quot; $ T $ &quot;)file.write(&quot;\\item &quot;+word+&quot; &quot;+pronunciation+&quot; $ &quot;+part_of_speech+&quot; $ &quot;+attri+&quot; &quot;+chinese+&quot;\n&quot;)if len(example_CHN)&gt;0:file.write(&quot;\\begin&#123;itemize&#125;\n&quot;)while len(example_CHN)&gt;3:example_CHN.pop()example_ENG.pop()for i in range(len(example_CHN)):file.write(&quot;\\item[$\\diamond$] &quot;)file.write(example_ENG[i].text.replace(&quot;$&quot;,&quot; \\$ &quot;))file.write(&quot;\n&quot;)file.write(example_CHN[i].text.replace(&quot;%&quot;,&quot; $ \\% $ &quot;))file.write(&quot;\n&quot;)file.write(&quot;\\end&#123;itemize&#125;\n&quot;)# if len(sentence)!&#x3D;0:# file.write(&quot;sentence:\n&quot;)# file.write(&quot;\\begin&#123;itemize&#125;\n&quot;)# for i in sentence:# file.write(&quot;\\item[$\\diamond$] &quot;)# file.write(i.text)# file.write(&quot;\n&quot;)# file.write(&quot;\\end&#123;itemize&#125;\n&quot;)file.write(&quot;\\end&#123;itemize&#125;\n&quot;)lock.release()except:print(&quot;Error occured on word &quot;+word+&quot;, please check the code or spelling.&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Templates</title>
      <link href="/2023/10/27/cpp-templates/"/>
      <url>/2023/10/27/cpp-templates/</url>
      
        <content type="html"><![CDATA[<h2 id="FastIO-from-Matrix-mlt"><a href="#FastIO-from-Matrix-mlt" class="headerlink" title="FastIO from Matrix_mlt"></a>FastIO from Matrix_mlt</h2><pre class="line-numbers language-none"><code class="language-none">namespace FastIO&#123;static constexpr int SIZE &#x3D; 1 &lt;&lt; 21;char ibuf[SIZE], obuf[SIZE], *p1 &#x3D; ibuf, *p2 &#x3D; ibuf, *p3 &#x3D; obuf;inline void read(char &amp;c)&#123;for (c &#x3D; gc(); !std::isgraph(c); c &#x3D; gc());&#125;inline void read(char *s)&#123;char c &#x3D; gc();for (; !std::isgraph(c); c &#x3D; gc());for (; std::isgraph(c); c &#x3D; gc())*s++ &#x3D; c;*s &#x3D; 0;&#125;inline void read(std::string &amp;s)&#123;s.clear();char c &#x3D; gc();for (; !std::isgraph(c); c &#x3D; gc());for (; std::isgraph(c); c &#x3D; gc())s.push_back(c);&#125;inline void pc(char c)&#123;if (p3 - obuf &#x3D;&#x3D; SIZE)fwrite(obuf, 1, SIZE, stdout), p3 &#x3D; obuf;*p3++ &#x3D; c;&#125;inline void write(char c) &#123; pc(c); &#125;inline void write(const char *s)&#123;while (*s)pc(*s), ++s;&#125;inline void write(std::string s)&#123;for (const char c : s)pc(c);&#125;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123;x &#x3D; 0;char c &#x3D; gc();int f &#x3D; 0;for (; !std::isdigit(c); c &#x3D; gc())f |&#x3D; c &#x3D;&#x3D; &#39;-&#39;;for (; std::isdigit(c); c &#x3D; gc())x &#x3D; (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);return f ? x &#x3D; ~x + 1 : 1, void();&#125;template &lt;typename _Tp&gt;inline void write(_Tp x)&#123;static int stk[40];int tp &#x3D; 0;if (!x)return pc(&#39;0&#39;), void();if (x &lt; 0)pc(&#39;-&#39;), x &#x3D; ~x + 1;while (x)stk[++tp] &#x3D; x % 10, x &#x2F;&#x3D; 10;while (tp)pc(stk[tp--] + &#39;0&#39;);&#125;template &lt;typename _Tp&gt;inline void writesp(_Tp x)&#123;write(x);pc(&#39; &#39;);&#125;template &lt;typename _Tp&gt;inline void writeln(_Tp x) &#123; write(x), pc(&#39;\n&#39;); &#125;template &lt;typename _Tp, typename... Args&gt;inline void read(_Tp &amp;x, Args &amp;...args) &#123; read(x), read(args...); &#125;template &lt;typename _Tp, typename... Args&gt;inline void write(_Tp x, Args... args) &#123; write(x), write(args...); &#125;template &lt;typename _Tp, typename... Args&gt;inline void writesp(_Tp x, Args... args) &#123; writesp(x), writesp(args...); &#125;template &lt;typename _Tp, typename... Args&gt;inline void writeln(_Tp x, Args... args) &#123; writeln(x), writeln(args...); &#125;inline void flush() &#123; fwrite(obuf, p3 - obuf, 1, stdout); &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Quick-Power-calculate-a-b-mod-p-in-O-log-n"><a href="#Quick-Power-calculate-a-b-mod-p-in-O-log-n" class="headerlink" title="Quick Power (calculate $a^b$ mod $p$ in $O(\log n)$ )"></a>Quick Power (calculate $a^b$ mod $p$ in $O(\log n)$ )</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">quickpower</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token comment">// calculate $ a^b mod p $</span><span class="token punctuation">&#123;</span>a <span class="token operator">%=</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> base <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ans <span class="token operator">=</span> ans <span class="token operator">*</span> base <span class="token operator">%</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>base <span class="token operator">=</span> base <span class="token operator">*</span> base <span class="token operator">%</span> p<span class="token punctuation">;</span>b <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Balancing-Tree-in-Segtree"><a href="#Balancing-Tree-in-Segtree" class="headerlink" title="Balancing Tree in Segtree"></a>Balancing Tree in Segtree</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#include &lt;bits&#x2F;extc++.h&gt;using namespace __gnu_pbds;using namespace __gnu_cxx;using namespace std;#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,lzcnt,abm,bmi,bmi2,fma,tune&#x3D;native&quot;)&#x2F;&#x2F; #pragma GCC optimize(2)#define endl &quot;\n&quot;#define problemname &quot;P3380&quot;#define gc() (p1 &#x3D;&#x3D; p2 &amp;&amp; (p2 &#x3D; (p1 &#x3D; ibuf) + fread(ibuf, 1, SIZE, stdin), p1 &#x3D;&#x3D; p2) ? EOF : *p1++)namespace FastIO&#123;static constexpr int SIZE &#x3D; 1 &lt;&lt; 21;char ibuf[SIZE], obuf[SIZE], *p1 &#x3D; ibuf, *p2 &#x3D; ibuf, *p3 &#x3D; obuf;inline void read(char &amp;c)&#123;for (c &#x3D; gc(); !std::isgraph(c); c &#x3D; gc());&#125;inline void read(char *s)&#123;char c &#x3D; gc();for (; !std::isgraph(c); c &#x3D; gc());for (; std::isgraph(c); c &#x3D; gc())*s++ &#x3D; c;*s &#x3D; 0;&#125;inline void read(std::string &amp;s)&#123;s.clear();char c &#x3D; gc();for (; !std::isgraph(c); c &#x3D; gc());for (; std::isgraph(c); c &#x3D; gc())s.push_back(c);&#125;inline void pc(char c)&#123;if (p3 - obuf &#x3D;&#x3D; SIZE)fwrite(obuf, 1, SIZE, stdout), p3 &#x3D; obuf;*p3++ &#x3D; c;&#125;inline void write(char c) &#123; pc(c); &#125;inline void write(const char *s)&#123;while (*s)pc(*s), ++s;&#125;inline void write(std::string s)&#123;for (const char c : s)pc(c);&#125;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123;x &#x3D; 0;char c &#x3D; gc();int f &#x3D; 0;for (; !std::isdigit(c); c &#x3D; gc())f |&#x3D; c &#x3D;&#x3D; &#39;-&#39;;for (; std::isdigit(c); c &#x3D; gc())x &#x3D; (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);return f ? x &#x3D; ~x + 1 : 1, void();&#125;template &lt;typename _Tp&gt;inline void write(_Tp x)&#123;static int stk[40];int tp &#x3D; 0;if (!x)return pc(&#39;0&#39;), void();if (x &lt; 0)pc(&#39;-&#39;), x &#x3D; ~x + 1;while (x)stk[++tp] &#x3D; x % 10, x &#x2F;&#x3D; 10;while (tp)pc(stk[tp--] + &#39;0&#39;);&#125;template &lt;typename _Tp&gt;inline void writesp(_Tp x)&#123;write(x);pc(&#39; &#39;);&#125;template &lt;typename _Tp&gt;inline void writeln(_Tp x) &#123; write(x), pc(&#39;\n&#39;); &#125;template &lt;typename _Tp, typename... Args&gt;inline void read(_Tp &amp;x, Args &amp;...args) &#123; read(x), read(args...); &#125;template &lt;typename _Tp, typename... Args&gt;inline void write(_Tp x, Args... args) &#123; write(x), write(args...); &#125;template &lt;typename _Tp, typename... Args&gt;inline void writesp(_Tp x, Args... args) &#123; writesp(x), writesp(args...); &#125;template &lt;typename _Tp, typename... Args&gt;inline void writeln(_Tp x, Args... args) &#123; writeln(x), writeln(args...); &#125;inline void flush() &#123; fwrite(obuf, p3 - obuf, 1, stdout); &#125;&#125;#define const constexprconst int N &#x3D; 1e5 + 5;namespace Main&#123;vector&lt;int&gt; num &#x3D; vector&lt;int&gt;(1);struct Splay&#123;int tot &#x3D; 0;struct node&#123;int val &#x3D; 0, cnt &#x3D; 0, size &#x3D; 1;node *son[2] &#x3D; &#123;nullptr, nullptr&#125;, *father &#x3D; nullptr;node()&#123;return;&#125;node(int a, int b, int c)&#123;val &#x3D; a, cnt &#x3D; b, size &#x3D; c;&#125;node(int a, int b, int c, node &amp;d, node &amp;e)&#123;val &#x3D; a, cnt &#x3D; b, size &#x3D; c;son[0] &#x3D; &amp;d, son[1] &#x3D; &amp;e;&#125;&#125;;node *root&#x3D;nullptr;void maintain(node *u)&#123;if (!u)&#123;return;&#125;u-&gt;size &#x3D; (u-&gt;son[0] ? u-&gt;son[0]-&gt;size : 0) + (u-&gt;son[1] ? u-&gt;son[1]-&gt;size : 0) + u-&gt;cnt;&#125;bool check(node *u)&#123;return u-&gt;father &amp;&amp; (u &#x3D;&#x3D; (u-&gt;father-&gt;son[1]));&#125;void rotate(node *x)&#123;auto f1 &#x3D; x-&gt;father, f2 &#x3D; f1-&gt;father;auto r1 &#x3D; check(x);if (x-&gt;son[r1 ^ 1])&#123;x-&gt;son[r1 ^ 1]-&gt;father &#x3D; f1;f1-&gt;son[r1] &#x3D; x-&gt;son[r1 ^ 1];&#125;f1-&gt;son[r1] &#x3D; x-&gt;son[r1 ^ 1];x-&gt;son[r1 ^ 1] &#x3D; f1;x-&gt;father &#x3D; f2;f1-&gt;father &#x3D; x;if (f2)&#123;f2-&gt;son[f1 &#x3D;&#x3D; f2-&gt;son[1]] &#x3D; x;&#125;maintain(f1), maintain(x);&#125;void splay(node *x)&#123;for (auto father &#x3D; x-&gt;father; father &#x3D; x-&gt;father, father; rotate(x))&#123;if (father-&gt;father)&#123;rotate(check(x) &#x3D;&#x3D; check(father) ? father : x);&#125;&#125;root &#x3D; x;&#125;void insert(int val)&#123;if (root)&#123;auto cur &#x3D; root;while (1)&#123;if (cur-&gt;val &#x3D;&#x3D; val)&#123;++cur-&gt;cnt;maintain(cur);maintain(cur-&gt;father);splay(cur);break;&#125;&#x2F;&#x2F; auto father &#x3D; cur-&gt;father;if (cur-&gt;son[cur-&gt;val &lt; val])&#123;cur &#x3D; cur-&gt;son[cur-&gt;val &lt; val];&#125;else&#123;cur-&gt;son[cur-&gt;val &lt; val] &#x3D; new node;cur-&gt;son[cur-&gt;val &lt; val]-&gt;val &#x3D; val;++cur-&gt;son[cur-&gt;val &lt; val]-&gt;cnt;cur-&gt;son[cur-&gt;val &lt; val]-&gt;father &#x3D; cur;maintain(cur);maintain(cur-&gt;son[cur-&gt;val &lt; val]);splay(cur-&gt;son[cur-&gt;val &lt; val]);break;&#125;&#125;&#125;else&#123;root &#x3D; new node;root-&gt;cnt &#x3D; 1;root-&gt;size &#x3D; 1;root-&gt;val &#x3D; val;maintain(root);&#125;&#125;int rk(int k)&#123;auto cur &#x3D; root;int now &#x3D; 0;while (1)&#123;if (k &lt; cur-&gt;val)&#123;if (cur-&gt;son[0])&#123;cur &#x3D; cur-&gt;son[0];&#125;else&#123;splay(cur);return now + 1;&#125;&#125;else if (k&gt;cur-&gt;val)&#123;now +&#x3D; (cur-&gt;son[0] ? cur-&gt;son[0]-&gt;size : 0);now +&#x3D; cur-&gt;cnt;if(cur-&gt;son[1])&#123;cur &#x3D; cur-&gt;son[1];&#125;else&#123;splay(cur);return now + 1;&#125;&#125;else&#123;now +&#x3D; (cur-&gt;son[0] ? cur-&gt;son[0]-&gt;size : 0);splay(cur);return now + 1;&#125;&#125;&#125;int kth(int k)&#123;auto cur &#x3D; root;while (1)&#123;if (cur-&gt;son[0] &amp;&amp; k &lt;&#x3D; cur-&gt;son[0]-&gt;size)&#123;cur &#x3D; cur-&gt;son[0];&#125;else if (cur-&gt;son[1])&#123;k -&#x3D; cur-&gt;cnt + (cur-&gt;son[0] ? cur-&gt;son[0]-&gt;size : 0);if (k &lt;&#x3D; 0)&#123;splay(cur);return cur-&gt;val;&#125;cur &#x3D; cur-&gt;son[1];&#125;else&#123;splay(cur);return cur-&gt;val;&#125;&#125;&#125;node *pre(node *x)&#123;auto cur &#x3D; x-&gt;son[0];if (!cur)&#123;return x;&#125;while (cur-&gt;son[1])&#123;cur &#x3D; cur-&gt;son[1];&#125;splay(cur);return cur;&#125;node *nxt(node *x)&#123;auto cur &#x3D; x-&gt;son[1];if (!cur)&#123;return x;&#125;while (cur-&gt;son[0])&#123;cur &#x3D; cur-&gt;son[0];&#125;splay(cur);return cur;&#125;void del(int x)&#123;rk(x);auto cur &#x3D; root;if (cur-&gt;cnt &gt; 1)&#123;--cur-&gt;cnt;maintain(cur);return;&#125;if (!cur-&gt;son[0] &amp;&amp; !cur-&gt;son[1])&#123;root &#x3D; nullptr;return;&#125;if (!cur-&gt;son[0])&#123;root &#x3D; cur-&gt;son[1];root-&gt;father &#x3D; nullptr;return;&#125;auto oldroot &#x3D; root;node *x1 &#x3D; pre(root);if (cur-&gt;son[1])&#123;cur-&gt;son[1]-&gt;father &#x3D; x1;&#125;x1-&gt;son[1] &#x3D; cur-&gt;son[1];delete oldroot;maintain(root);&#125;&#125;;struct Segtree&#123;struct node&#123;int cl, cr;node *son[2] &#x3D; &#123;nullptr, nullptr&#125;, *father &#x3D; nullptr;Splay *tree;node()&#123;tree &#x3D; new Splay;&#125;&#125;;vector&lt;int&gt; *arr;node *root;Segtree()&#123;arr &#x3D; nullptr;root &#x3D; nullptr;&#125;Segtree(vector&lt;int&gt; &amp;a)&#123;arr &#x3D; &amp;a;root &#x3D; build_tree(1, arr-&gt;size() - 1, nullptr);&#125;node *build_tree(int cl, int cr, node *fa)&#123;node *p &#x3D; new node;p-&gt;father &#x3D; fa;p-&gt;cl &#x3D; cl, p-&gt;cr &#x3D; cr;for (auto i &#x3D; arr-&gt;begin() + cl; i &lt;&#x3D; arr-&gt;begin() + cr; i++)&#123;p-&gt;tree-&gt;insert(*i);&#125;if (cl &#x3D;&#x3D; cr)&#123;return p;&#125;int mid &#x3D; (cl + cr) &gt;&gt; 1;p-&gt;son[0] &#x3D; build_tree(cl, mid, p);p-&gt;son[1] &#x3D; build_tree(mid + 1, cr, p);return p;&#125;void modify(int k, int val, node *p)&#123;p-&gt;tree-&gt;del(arr-&gt;at(k));p-&gt;tree-&gt;insert(val);if (p-&gt;cl &#x3D;&#x3D; p-&gt;cr)&#123;return;&#125;else&#123;return modify(k, val, p-&gt;son[(p-&gt;son[0]-&gt;cr &lt; k)]);&#125;&#125;void modify(int k, int val)&#123;modify(k, val, root);(*arr)[k] &#x3D; val;&#125;int rnk(int l, int r, int k, node *p)&#123;if (l &lt;&#x3D; p-&gt;cl &amp;&amp; p-&gt;cr &lt;&#x3D; r)&#123;&#x2F;&#x2F; p-&gt;tree-&gt;insert(k);int res &#x3D; p-&gt;tree-&gt;rk(k) - 1;&#x2F;&#x2F; p-&gt;tree-&gt;del(k);return res;&#125;int res &#x3D; 0;if (l &lt;&#x3D; p-&gt;son[0]-&gt;cr)&#123;res +&#x3D; rnk(l, r, k, p-&gt;son[0]);&#125;if (r &gt;&#x3D; p-&gt;son[1]-&gt;cl)&#123;res +&#x3D; rnk(l, r, k, p-&gt;son[1]);&#125;return res;&#125;int rnk(int l, int r, int k)&#123;return rnk(l, r, k, root) + 1;&#125;int pre(int l, int r, int val, node *p)&#123;if (l &lt;&#x3D; p-&gt;cl &amp;&amp; p-&gt;cr &lt;&#x3D; r)&#123;p-&gt;tree-&gt;insert(val);int ans &#x3D; p-&gt;tree-&gt;pre(p-&gt;tree-&gt;root)-&gt;val;p-&gt;tree-&gt;del(val);if (ans &gt;&#x3D; val)&#123;return -2147483647;&#125;return ans;&#125;int ans &#x3D; INT_MIN;if (l &lt;&#x3D; p-&gt;son[0]-&gt;cr)&#123;ans &#x3D; max(ans, pre(l, r, val, p-&gt;son[0]));&#125;if (r &gt;&#x3D; p-&gt;son[1]-&gt;cl)&#123;ans &#x3D; max(ans, pre(l, r, val, p-&gt;son[1]));&#125;return ans;&#125;int pre(int l, int r, int val)&#123;return pre(l, r, val, root);&#125;int nxt(int l, int r, int val, node *p)&#123;if (l &lt;&#x3D; p-&gt;cl &amp;&amp; p-&gt;cr &lt;&#x3D; r)&#123;p-&gt;tree-&gt;insert(val);int ans &#x3D; p-&gt;tree-&gt;nxt(p-&gt;tree-&gt;root)-&gt;val;p-&gt;tree-&gt;del(val);if (ans &lt;&#x3D; val)&#123;return 2147483647;&#125;return ans;&#125;int ans &#x3D; 2147483647;if (l &lt;&#x3D; p-&gt;son[0]-&gt;cr)&#123;ans &#x3D; min(ans, nxt(l, r, val, p-&gt;son[0]));&#125;if (r &gt;&#x3D; p-&gt;son[1]-&gt;cl)&#123;ans &#x3D; min(ans, nxt(l, r, val, p-&gt;son[1]));&#125;return ans;&#125;int nxt(int l, int r, int val)&#123;return nxt(l, r, val, root);&#125;int kth(int l, int r, int val)&#123;int cl &#x3D; -1, cr &#x3D; 1e8 + 1, mid;while (cl &lt; cr)&#123;mid &#x3D; (cl + cr + 1) &gt;&gt; 1;if (rnk(l, r, mid) &lt;&#x3D; val)&#123;cl &#x3D; mid;&#125;else&#123;cr &#x3D; mid - 1;&#125;&#125;return cl;&#125;&#125; Tree;int main()&#123;int n, m;FastIO::read(n, m);for (int i &#x3D; 1, temp; i &lt;&#x3D; n; i++)&#123;FastIO::read(temp);num.push_back(temp);&#125;Tree &#x3D; Segtree(num);int opt, l, r, pos, x;while (m--)&#123;FastIO::read(opt);switch (opt)&#123;case 1:FastIO::read(l, r, x);FastIO::writeln(Tree.rnk(l, r, x));break;case 2:FastIO::read(l, r, x);FastIO::writeln(Tree.kth(l, r, x));break;case 3:FastIO::read(pos, x);Tree.modify(pos, x);break;case 4:FastIO::read(l, r, x);FastIO::writeln(Tree.pre(l, r, x));break;case 5:FastIO::read(l, r, x);FastIO::writeln(Tree.nxt(l, r, x));break;&#125;&#125;FastIO::flush();return 0;&#125;&#125;;signed main()&#123;#ifndef ONLINE_JUDGEfreopen(problemname &quot;_8.in&quot;, &quot;r&quot;, stdin);freopen(problemname &quot;.out&quot;, &quot;w&quot;, stdout);#endifios::sync_with_stdio(false);cin.tie(0), cout.tie(0);Main::main();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/27/hello-world/"/>
      <url>/2023/10/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
