{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/10/27/hello-world/"},{"title":"C++ Templates","text":"Balancing Tree in Segtree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace __gnu_pbds;using namespace __gnu_cxx;using namespace std;#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,lzcnt,abm,bmi,bmi2,fma,tune=native&quot;)// #pragma GCC optimize(2)#define endl &quot;\\n&quot;#define problemname &quot;P3380&quot;#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, SIZE, stdin), p1 == p2) ? EOF : *p1++)namespace FastIO{ static constexpr int SIZE = 1 &lt;&lt; 21; char ibuf[SIZE], obuf[SIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf; inline void read(char &amp;c) { for (c = gc(); !std::isgraph(c); c = gc()) ; } inline void read(char *s) { char c = gc(); for (; !std::isgraph(c); c = gc()) ; for (; std::isgraph(c); c = gc()) *s++ = c; *s = 0; } inline void read(std::string &amp;s) { s.clear(); char c = gc(); for (; !std::isgraph(c); c = gc()) ; for (; std::isgraph(c); c = gc()) s.push_back(c); } inline void pc(char c) { if (p3 - obuf == SIZE) fwrite(obuf, 1, SIZE, stdout), p3 = obuf; *p3++ = c; } inline void write(char c) { pc(c); } inline void write(const char *s) { while (*s) pc(*s), ++s; } inline void write(std::string s) { for (const char c : s) pc(c); } template &lt;typename _Tp&gt; inline void read(_Tp &amp;x) { x = 0; char c = gc(); int f = 0; for (; !std::isdigit(c); c = gc()) f |= c == '-'; for (; std::isdigit(c); c = gc()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); return f ? x = ~x + 1 : 1, void(); } template &lt;typename _Tp&gt; inline void write(_Tp x) { static int stk[40]; int tp = 0; if (!x) return pc('0'), void(); if (x &lt; 0) pc('-'), x = ~x + 1; while (x) stk[++tp] = x % 10, x /= 10; while (tp) pc(stk[tp--] + '0'); } template &lt;typename _Tp&gt; inline void writesp(_Tp x) { write(x); pc(' '); } template &lt;typename _Tp&gt; inline void writeln(_Tp x) { write(x), pc('\\n'); } template &lt;typename _Tp, typename... Args&gt; inline void read(_Tp &amp;x, Args &amp;...args) { read(x), read(args...); } template &lt;typename _Tp, typename... Args&gt; inline void write(_Tp x, Args... args) { write(x), write(args...); } template &lt;typename _Tp, typename... Args&gt; inline void writesp(_Tp x, Args... args) { writesp(x), writesp(args...); } template &lt;typename _Tp, typename... Args&gt; inline void writeln(_Tp x, Args... args) { writeln(x), writeln(args...); } inline void flush() { fwrite(obuf, p3 - obuf, 1, stdout); }}#define const constexprconst int N = 1e5 + 5;namespace Main{ vector&lt;int&gt; num = vector&lt;int&gt;(1); struct Splay { int tot = 0; struct node { int val = 0, cnt = 0, size = 1; node *son[2] = {nullptr, nullptr}, *father = nullptr; node() { return; } node(int a, int b, int c) { val = a, cnt = b, size = c; } node(int a, int b, int c, node &amp;d, node &amp;e) { val = a, cnt = b, size = c; son[0] = &amp;d, son[1] = &amp;e; } }; node *root=nullptr; void maintain(node *u) { if (!u) { return; } u-&gt;size = (u-&gt;son[0] ? u-&gt;son[0]-&gt;size : 0) + (u-&gt;son[1] ? u-&gt;son[1]-&gt;size : 0) + u-&gt;cnt; } bool check(node *u) { return u-&gt;father &amp;&amp; (u == (u-&gt;father-&gt;son[1])); } void rotate(node *x) { auto f1 = x-&gt;father, f2 = f1-&gt;father; auto r1 = check(x); if (x-&gt;son[r1 ^ 1]) { x-&gt;son[r1 ^ 1]-&gt;father = f1; f1-&gt;son[r1] = x-&gt;son[r1 ^ 1]; } f1-&gt;son[r1] = x-&gt;son[r1 ^ 1]; x-&gt;son[r1 ^ 1] = f1; x-&gt;father = f2; f1-&gt;father = x; if (f2) { f2-&gt;son[f1 == f2-&gt;son[1]] = x; } maintain(f1), maintain(x); } void splay(node *x) { for (auto father = x-&gt;father; father = x-&gt;father, father; rotate(x)) { if (father-&gt;father) { rotate(check(x) == check(father) ? father : x); } } root = x; } void insert(int val) { if (root) { auto cur = root; while (1) { if (cur-&gt;val == val) { ++cur-&gt;cnt; maintain(cur); maintain(cur-&gt;father); splay(cur); break; } // auto father = cur-&gt;father; if (cur-&gt;son[cur-&gt;val &lt; val]) { cur = cur-&gt;son[cur-&gt;val &lt; val]; } else { cur-&gt;son[cur-&gt;val &lt; val] = new node; cur-&gt;son[cur-&gt;val &lt; val]-&gt;val = val; ++cur-&gt;son[cur-&gt;val &lt; val]-&gt;cnt; cur-&gt;son[cur-&gt;val &lt; val]-&gt;father = cur; maintain(cur); maintain(cur-&gt;son[cur-&gt;val &lt; val]); splay(cur-&gt;son[cur-&gt;val &lt; val]); break; } } } else { root = new node; root-&gt;cnt = 1; root-&gt;size = 1; root-&gt;val = val; maintain(root); } } int rk(int k) { auto cur = root; int now = 0; while (1) { if (k &lt; cur-&gt;val) { if (cur-&gt;son[0]) { cur = cur-&gt;son[0]; } else { splay(cur); return now + 1; } } else if (k&gt;cur-&gt;val) { now += (cur-&gt;son[0] ? cur-&gt;son[0]-&gt;size : 0); now += cur-&gt;cnt; if(cur-&gt;son[1]){ cur = cur-&gt;son[1];} else{ splay(cur); return now + 1; } } else { now += (cur-&gt;son[0] ? cur-&gt;son[0]-&gt;size : 0); splay(cur); return now + 1; } } } int kth(int k) { auto cur = root; while (1) { if (cur-&gt;son[0] &amp;&amp; k &lt;= cur-&gt;son[0]-&gt;size) { cur = cur-&gt;son[0]; } else if (cur-&gt;son[1]) { k -= cur-&gt;cnt + (cur-&gt;son[0] ? cur-&gt;son[0]-&gt;size : 0); if (k &lt;= 0) { splay(cur); return cur-&gt;val; } cur = cur-&gt;son[1]; } else { splay(cur); return cur-&gt;val; } } } node *pre(node *x) { auto cur = x-&gt;son[0]; if (!cur) { return x; } while (cur-&gt;son[1]) { cur = cur-&gt;son[1]; } splay(cur); return cur; } node *nxt(node *x) { auto cur = x-&gt;son[1]; if (!cur) { return x; } while (cur-&gt;son[0]) { cur = cur-&gt;son[0]; } splay(cur); return cur; } void del(int x) { rk(x); auto cur = root; if (cur-&gt;cnt &gt; 1) { --cur-&gt;cnt; maintain(cur); return; } if (!cur-&gt;son[0] &amp;&amp; !cur-&gt;son[1]) { root = nullptr; return; } if (!cur-&gt;son[0]) { root = cur-&gt;son[1]; root-&gt;father = nullptr; return; } auto oldroot = root; node *x1 = pre(root); if (cur-&gt;son[1]) { cur-&gt;son[1]-&gt;father = x1; } x1-&gt;son[1] = cur-&gt;son[1]; delete oldroot; maintain(root); } }; struct Segtree { struct node { int cl, cr; node *son[2] = {nullptr, nullptr}, *father = nullptr; Splay *tree; node() { tree = new Splay; } }; vector&lt;int&gt; *arr; node *root; Segtree() { arr = nullptr; root = nullptr; } Segtree(vector&lt;int&gt; &amp;a) { arr = &amp;a; root = build_tree(1, arr-&gt;size() - 1, nullptr); } node *build_tree(int cl, int cr, node *fa) { node *p = new node; p-&gt;father = fa; p-&gt;cl = cl, p-&gt;cr = cr; for (auto i = arr-&gt;begin() + cl; i &lt;= arr-&gt;begin() + cr; i++) { p-&gt;tree-&gt;insert(*i); } if (cl == cr) { return p; } int mid = (cl + cr) &gt;&gt; 1; p-&gt;son[0] = build_tree(cl, mid, p); p-&gt;son[1] = build_tree(mid + 1, cr, p); return p; } void modify(int k, int val, node *p) { p-&gt;tree-&gt;del(arr-&gt;at(k)); p-&gt;tree-&gt;insert(val); if (p-&gt;cl == p-&gt;cr) { return; } else { return modify(k, val, p-&gt;son[(p-&gt;son[0]-&gt;cr &lt; k)]); } } void modify(int k, int val) { modify(k, val, root); (*arr)[k] = val; } int rnk(int l, int r, int k, node *p) { if (l &lt;= p-&gt;cl &amp;&amp; p-&gt;cr &lt;= r) { // p-&gt;tree-&gt;insert(k); int res = p-&gt;tree-&gt;rk(k) - 1; // p-&gt;tree-&gt;del(k); return res; } int res = 0; if (l &lt;= p-&gt;son[0]-&gt;cr) { res += rnk(l, r, k, p-&gt;son[0]); } if (r &gt;= p-&gt;son[1]-&gt;cl) { res += rnk(l, r, k, p-&gt;son[1]); } return res; } int rnk(int l, int r, int k) { return rnk(l, r, k, root) + 1; } int pre(int l, int r, int val, node *p) { if (l &lt;= p-&gt;cl &amp;&amp; p-&gt;cr &lt;= r) { p-&gt;tree-&gt;insert(val); int ans = p-&gt;tree-&gt;pre(p-&gt;tree-&gt;root)-&gt;val; p-&gt;tree-&gt;del(val); if (ans &gt;= val) { return -2147483647; } return ans; } int ans = INT_MIN; if (l &lt;= p-&gt;son[0]-&gt;cr) { ans = max(ans, pre(l, r, val, p-&gt;son[0])); } if (r &gt;= p-&gt;son[1]-&gt;cl) { ans = max(ans, pre(l, r, val, p-&gt;son[1])); } return ans; } int pre(int l, int r, int val) { return pre(l, r, val, root); } int nxt(int l, int r, int val, node *p) { if (l &lt;= p-&gt;cl &amp;&amp; p-&gt;cr &lt;= r) { p-&gt;tree-&gt;insert(val); int ans = p-&gt;tree-&gt;nxt(p-&gt;tree-&gt;root)-&gt;val; p-&gt;tree-&gt;del(val); if (ans &lt;= val) { return 2147483647; } return ans; } int ans = 2147483647; if (l &lt;= p-&gt;son[0]-&gt;cr) { ans = min(ans, nxt(l, r, val, p-&gt;son[0])); } if (r &gt;= p-&gt;son[1]-&gt;cl) { ans = min(ans, nxt(l, r, val, p-&gt;son[1])); } return ans; } int nxt(int l, int r, int val) { return nxt(l, r, val, root); } int kth(int l, int r, int val) { int cl = -1, cr = 1e8 + 1, mid; while (cl &lt; cr) { mid = (cl + cr + 1) &gt;&gt; 1; if (rnk(l, r, mid) &lt;= val) { cl = mid; } else { cr = mid - 1; } } return cl; } } Tree; int main() { int n, m; FastIO::read(n, m); for (int i = 1, temp; i &lt;= n; i++) { FastIO::read(temp); num.push_back(temp); } Tree = Segtree(num); int opt, l, r, pos, x; while (m--) { FastIO::read(opt); switch (opt) { case 1: FastIO::read(l, r, x); FastIO::writeln(Tree.rnk(l, r, x)); break; case 2: FastIO::read(l, r, x); FastIO::writeln(Tree.kth(l, r, x)); break; case 3: FastIO::read(pos, x); Tree.modify(pos, x); break; case 4: FastIO::read(l, r, x); FastIO::writeln(Tree.pre(l, r, x)); break; case 5: FastIO::read(l, r, x); FastIO::writeln(Tree.nxt(l, r, x)); break; } } FastIO::flush(); return 0; }};signed main(){#ifndef ONLINE_JUDGE freopen(problemname &quot;_8.in&quot;, &quot;r&quot;, stdin); freopen(problemname &quot;.out&quot;, &quot;w&quot;, stdout);#endif ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); Main::main(); return 0;}","link":"/2023/10/27/Cpp-templates/"}],"tags":[],"categories":[],"pages":[]}